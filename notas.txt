//instalar el paquete nodemon para que el server se actualize cada vez que se guarde un archivo
  npm install --save-dev nodemon
  package.json/scripts : "start": "nodemon server.js"
  npm start

//login package to log incoming requests (para ver info en la terminal)
  npm install --save morgan
  app.js/ const morgan = require('morgan');
  app.js/ app.use(morgan('dev'));

//Capitulo 5: manejo del body de requests: no soporta files, pero si: URL encoded bodies y JSON data
  npm install --save body-parser
  app.js/ const bodyParser = require('body-parser');
  los atributos del json en postman deben ir encerrados en "" incluyendo los campos
  CORS ERRORS: son error Cross-Origin Resource Sharing, basicamente son errores que se presentan al querer acceder a nuestra API desde otro servidor
              y se deniega el acceso, asi que hay que permitirlo por medio de "Headers".
  Porque no hay problema con PostMan? Porque le vale verga ya que es una herramienta de simulacion

//Capitulo 6: MongoDB, Mongoose
  Sign up for MongoDB Atlas, porque es en la nube
  Crea una cuenta y configurarla
  Pon en la whitelist que todos puedan acceder a esa base de datos
  connect, seleccione el 3.6 para arriba
  --consola
    npm install --save mongoose
  Introducimos el uso de modelos, para modelar como se veran los objetos para la base de datos. api/models
  --para variables de entorno
    npm install dotenv --save

//Capitulo 7: validaciones de mongoose y constrainsts para mejorar respuestas de las peticiones
    solo es mejorar nuestras respuestas de la api, docs, result.
    for deprecated mongoose promise: mongoose.Promise = global.Promise;

//Capitulo 8: manejo de ordenes
    esto es para hacer el modelo de ordenes y la verificacion de post para evitar la insercion de una orden con un Id de un producto
    INEXISTENTE

//Capitulo 9: populating Querys
  --merge querys to display all information

//Capitulo 10 Multer y el manejo de imagenes
    npm install --save multer
    //En vez de usar el raw de json usamos el tipo form para enviar los parametros y files que queremos y en headers,
    quitamos el content type application/json
    //se usan estrategias de guardado de files y filtros de files que queremos que se envien
    // se hace que el folder uploads sea publico en app.js

//Capitulo 11 User sign up y verificacion de usuario, encryptacion
  //la creacion de un modelo de usuario
  //la creacion de la ruta de usuario
  //surge el problema de los usuarios que no se encryptan, asi que habra que bajar un paquete para solucionar esto
  npm install bcrypt --save

Capitulo 12 User login y comparacion de passwords a travez de bcrypt, y JSONWEBTOKEN
  //bcrypt tiene su propio metodo de comparacion de contrasenas que es facil de implemetar ruta users/login
  //Instalamos otro paquete que se llama jsonwebtoken que nos facilita la creacion de un token
  npm install jsonwebtoken --save
  revisar porque no es compatible con jwt.io

Capitulo 13 Token como medio de acceso a rutas a travez del header
  //middleware para autenticacion e importacion de ese middleware como segundo parametro a las rutas que nos interesan que implementen
  esa autenticacion

Capitulo 14 Controladores, pasar las rutas como parametros de una funcion mejor
